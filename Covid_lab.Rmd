---
title: "Lab: Covid-19 + Census Data"
output: 
  learnr::tutorial:
  progressive: true
  allow_skip: false
runtime: shiny_prerendered
---

```{r setup, include = FALSE}
if(!require(learnr)) {
  install.packages("learnr")
}
library(learnr)

if(!require(dplyr)) {
  install.packages("dplyr")
}
library(dplyr)

if(!require(rgdal)) {
  install.packages("openintro")
}
library(rgdal)

if(!require(viridis)) {
  install.packages("openintro")
}
library(viridis)

if(!require(shiny)) {
  install.packages("shiny")
}
library(shiny)

if(!require(tidyr)) {
  install.packages("tidyr")
}
library(tidyr)

borough <- read.csv("data/data_summ_bor.csv")
zcta <- read.csv("data/data_summ_zcta.csv")
NYC_zips <- readOGR("Shape_Files/ZIP_CODE_040114.shp")

getShapeColors <- function(data, nbreaks=5, missingcol="gray88", rdgrbl=c(0,0,1), mycolors=NULL, max_opac=0.55){
  if(length(nbreaks) == 1) {
    mybreaks <- c(-1, quantile(data,
                               probs = seq(0, 1, length.out=nbreaks+1),
                               na.rm = T))
  } else {
    mybreaks <- c(-1,nbreaks)
  }
  if(!is.null(mycolors)){
    mycols <- mycolors
  } else {
    mycols <- rgb(rdgrbl[1],rdgrbl[2],rdgrbl[3],
                  seq(0.05,max_opac, length.out = length(mybreaks)-1))
  }
  mycols[1] <- missingcol
  data[is.na(data)] <- -.1
  mycolorscheme <- cut(data, mybreaks) %>%
    as.numeric()
  mycolorscheme <- mycols[mycolorscheme]
  levs <- levels(cut(data, mybreaks))
  levs[1] <- "No Data"
  return(list(mycolorscheme, levs, mycols))
}

knitr::opts_chunk$set(echo = FALSE)
```  
  
```{r load_data}

```
  
## The Data: A summary 
In this lab, you will inspect and interact with some data that has been compiled for you. The datasets loaded here were compiled using census data, COVID19 data (downloaded on April 23 from here: https://github.com/nychealth/coronavirus-data), and shape files for NYC zip codes (downloaded from here: https://data.cityofnewyork.us/widgets/i8iw-xf4u). You can see how this data was downloaded and merged by reading the accompanying Rmds in more detail. The purpose of this lab is to give you a chance to run some code and play with some of the data, while bypassing the need to download and load everything on your own computer. There are three files loaded for you in this space: data by zip code (called "zcta"), data by borough (called "borough"), and a shape file for plotting maps of nyc zip codes (called "NYC_zips").   



## Inspecting the data  

### Exercise: Print the first few rows

Use the `head()` function or square brackets to inspect the first 5 rows of the `borough` and `zcta` datasets. 
```{r inspect_data, exercise=TRUE, exercise.setup = 'load-data'}

```

```{r inspect_data-solution}
head(borough, 5)
head(zcta, 5)
#or:
borough[1:5,]
zcta[1:5,]
```
   
```{r 5row-quiz}
quiz(
  question("What is the median income in the Bronx?",
    answer("36381"),
    answer("59620"),
    answer("46586"),
    answer("27074", correct = TRUE)
  )
)

```  

### Exercise: Inspect the structure of the data    

Try using the `str()` function below to look at the structure of each dataset.  

```{r structure, exercise=TRUE, exercise.setup = 'load-data'}

```

```{r structure-solution}
str(borough)
str(zcta)
```
     
At this point, it might be useful to also inspect some of the variables more carefully to make sure we understand what they are. For now, let's focus on the zip-code level data. Looking at the data structure, we note that the second three variables are called "Positive," "Total," and "zcta_cum.perc_pos". "Positive" gives the number of positive tests by zipcode, "Total" gives the number of total tests by zipcode, and now we will show below that zcta_cum.perc_pos is just the percentage of total tests that were positive (i.e., Positive/Total*100, rounded to two decimals):    
```{r postotal, exercise=TRUE, exercise.setup = 'load-data'}
head(round(zcta$Positive/zcta$Total*100,2))
head(zcta$zcta_cum.perc_pos)
```
  
Another useful gut check: the census data includes a "total" variable for most demographic variables. In this dataset, we have collected the reported values for "Race_Total".. But is this the same as the full population? Initially, we collected both variables because it was important to check whether the two values are equivalent. It was possible that race information wasn't collected for the entire population and that the total number of people included in the race counts could be different from the full population. However, upon further inspection, these variables actually have the same values:   
```{r pop, exercise=TRUE, exercise.setup = 'load-data'}
head(zcta$Race_Total)
head(zcta$Population)
```
  
That said, you might notice that there is another variable called TotalPop. This variable was imported as part of the group of variables related to education level. Note that the values in this column are different from the Race_Total and Population columns. Looking at the documentation provided by the Census, it turns out this is because education level is only recorded for people over the age of 25.  
```{r pop2, exercise=TRUE, exercise.setup = 'load-data'}
head(zcta$Population)
head(zcta$TotalPop)
```

## 1 and 2-way Tables: Race/Income  
First, let's make a one way table of race, where race is defined as low, medium, and high proportion white (notice that case rates are higher in zip codes with a relatively low proportion of white people, and lower in zip codes with a relatively high proportion of white people). Activity: Run the provided code. Then see if you can change it so that there are only 2 categories for the White_Prop variable.    
```{r oneway_race, exercise=TRUE, exercise.setup = 'load-data'}
propwhite <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 3)) %>%
  group_by(White_Prop_Lev) %>%
  summarise(Cases_per_1000 = round(sum(Positive)/sum(Population)*1000, 2)) 
propwhite <- propwhite[-nrow(propwhite),]
propwhite
```

```{r oneway_race-solution}
propwhite <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 2)) %>%
  group_by(White_Prop_Lev) %>%
  summarise(Cases_per_1000 = round(sum(Positive)/sum(Population)*1000, 2)) 
propwhite <- propwhite[-nrow(propwhite),]
propwhite
```  
  
One way table of income, where income is defined as low income, medium income, and high income. (Notice that case rates are higher in zip codes with a relatively low median income, and lower in zip codes with a relatively high median income):  
```{r oneway_inc, exercise=TRUE, exercise.setup = 'load-data'}
inc <- zcta %>% 
  mutate(Med_Inc_Lev = ntile(Med_Income, 3)) %>%
  group_by(Med_Inc_Lev) %>%
  summarise(Cases_per_1000 = round(sum(Positive)/sum(Population)*1000, 2))
inc <- inc[-nrow(inc),]
inc
```
  

Let's try to reproduce a 2-way table of race and income. We notice something kind of interesting. It seems like case rates don't vary as much by income among zip codes with a low proportion of white people. Meanwhile, case rates vary a lot more by income among zip codes with a high proportion of white people.    
```{r twoway, exercise=TRUE, exercise.setup = 'load-data'}
inc_propwhite <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 3)) %>%
  mutate(Med_Inc_Lev = ntile(Med_Income, 3)) %>%
  group_by(White_Prop_Lev, Med_Inc_Lev) %>%
  summarise(Cases_per_1000 = round(sum(Positive)/sum(Population)*1000, 2)) %>%
  spread(White_Prop_Lev, Cases_per_1000, fill=0)
inc_propwhite <- inc_propwhite[-nrow(inc_propwhite),-ncol(inc_propwhite)]
inc_propwhite[,1] <- c("Low Income", "Med Income", "High Income")
colnames(inc_propwhite) <- c(NA, "Low Prop White", "Med Prop White", "High Prop White")
inc_propwhite
```

```{r twoway-solution}

```
  
For a moment, let's come back to the one-way table of the proportion of the population that is white. Here is another way we could have constructed that one-way table for race (this version is really a two-way table of race and case rate). The code below does the following: First, we divide the zip codes into two equally sized groups based on the proportion of the population that is white (half the zip codes are classified as having a high proportion of white people, half are classified as having a low proportion of white people). Then, we do the same thing by case rate (half the zip codes are classified as having a high case rate and half are classified as having a low case rate). Finally, we construct a 2-way table of these new categorical variables, where the values in the table are counts of zip codes. For example, there are 38 zip codes that are classified as having a low case rate AND a low proportion of white people.     
```{r oneway_race2, exercise=TRUE, exercise.setup = 'load-data'}
propwhite2 <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 2)) %>%
  mutate(Cases_per_1000 = round(Positive/Population*1000, 2)) %>%
  mutate(CaseRate_Lev = ntile(Cases_per_1000, 2)) %>%
  group_by(White_Prop_Lev, CaseRate_Lev) %>%
  summarise(N_Zips = n()) %>%
  spread(White_Prop_Lev, N_Zips, fill=0)
propwhite2 <- propwhite2[-nrow(propwhite2),-ncol(propwhite2)]
propwhite2[,1] <- c("Low Case Rate", "High Case Rate")
colnames(propwhite2) <- c(NA, "Low Prop White", "High Prop White")
propwhite2
```
  
We observe something that may or may not be surprising: There are more zip codes with a high proportion of white people and low case rate or low proportion of white people and high case rate (as compared to the other two categories). This suggests that zip codes with a higher proportion of non-white residents tend to have higher case rates. Can we test whether these differences are meaningful?     
Let's start with the value in the "low proportion white, high case rate category" (which is 57). We'll create a fake dataset that looks like the observed data (it would produce the same table as above), but then we will randomly reassign the levels of "proportion white" 1000 times, each time storing the number of zip codes in the low-white/high-case category. Then we can plot a histogram of the simulated values (with a vertical line at our observed value of 57). We can also calculate the proportion of simulated values greater than 57. See if you can follow the code below:    
```{r sim, exercise=TRUE, exercise.setup = 'load-data'}
numzips <- 38+57+57+37
num_low_white <- num_low_case <- 38+57
num_high_white <- num_high_case <- 57+37

simdata <- data.frame(CaseRate_Lev = c(rep(1, num_low_case), rep(2, num_high_case)),
                      White_Prop_Lev = c(rep(1, num_low_white), rep(2, num_high_white)))
set.seed(333)
simvals <- vector()
for(i in 1:1000){
  simdata$White_Prop_Lev <- sample(simdata$White_Prop_Lev)
  simvals[i] <- table(simdata)[2,1]
}

hist(simvals)
abline(v=57, lwd=2, col="blue")

#proportion of simulated values greater than 57
sum(simvals>=57)/1000
```
  
We note that only about 0.4% of our simulated values were greater than 57. It's therefore possible, but very unlikely that we would have observed this large of a value by random chance (if the truth was that there was no relationship between the proportion of the population that is white and the case rate). However, this cannot tell us WHY this relationship exists (there are many theories that have been proposed).   


### A quick side note:   

Another thing to take a look at: you may have noticed that we split case rate and proportion white into only two equally sized categories above. Here is the code again (except the code to specify the row and column names was taken out for now; see how to replace it in the "solution"). See if you can change the code to split the zip codes into 3, or even 4 categories. Do you notice a different pattern?  
```{r oneway_race3, exercise=TRUE, exercise.setup = 'load-data'}
propwhite2 <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 2)) %>%
  mutate(Cases_per_1000 = round(Positive/Population*1000, 2)) %>%
  mutate(CaseRate_Lev = ntile(Cases_per_1000, 2)) %>%
  group_by(White_Prop_Lev, CaseRate_Lev) %>%
  summarise(N_Zips = n()) %>%
  spread(White_Prop_Lev, N_Zips, fill=0)
propwhite2 <- propwhite2[-nrow(propwhite2),-ncol(propwhite2)]
propwhite2
```  
  
```{r oneway_race3-solution}
propwhite2 <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 3)) %>%
  mutate(Cases_per_1000 = round(Positive/Population*1000, 2)) %>%
  mutate(CaseRate_Lev = ntile(Cases_per_1000, 3)) %>%
  group_by(White_Prop_Lev, CaseRate_Lev) %>%
  summarise(N_Zips = n()) %>%
  spread(White_Prop_Lev, N_Zips, fill=0)
propwhite2 <- propwhite2[-nrow(propwhite2),-ncol(propwhite2)]
propwhite2[,1] <- c("Low Case Rate", "Medium Case Rate", "High Case Rate")
colnames(propwhite2) <- c(NA, "Low Prop White", "Medium Prop White", "High Prop White")
propwhite2
```
  
## Scatter Plots: Race/Income   
We can get a different, finer grain look at some of these relationships by looking at scatter plots. To start, we plot a scatter plot of the positive case rate as a function of the proportion of the population that is white.  
```{r scatter1, exercise=TRUE, exercise.setup = 'load-data'}
plot(zcta$White_Total/zcta$Population*100,
     round(zcta$Positive/zcta$Population*1000,1), 
     xlab="percent white", 
     ylab="pos cases per 1000 ppl", 
     pch=16)
```
  
Next, we do the same for positive case rate vs. income:  
```{r scatter2, exercise=TRUE, exercise.setup = 'load-data'}
plot(zcta$Med_Income,
     round(zcta$Positive/zcta$Population*1000,1), 
     xlab="median income", 
     ylab="pos cases per 1000 ppl", 
     pch=16)
```
  
And finally, percent white vs. median income:  
```{r scatter3, exercise=TRUE, exercise.setup = 'load-data'}
plot(zcta$Med_Income,
     zcta$White_Total/zcta$Population*100, 
     xlab="median income", 
     ylab="pos cases per 1000 ppl", 
     pch=16)
```  
   
   
## Mapping NYC    
In order to create a map of NYC, with zip codes colored by a particular variable, one first needs to download a shape file. A zip-code level shape file has been loaded here for you and is called NYC_zips. For those who are interested, this was loaded with the readOGR function from the rgdal package. Next, to make the plot useful, it is possible to determine the color of each zip code on the map based on values of a particular variable. We have written a function to do this and have copied it below so you can inspect it. The function is loaded for you to use in subsequent activities.  
```{r map1, exercise=TRUE, exercise.setup = 'load-data'}
getShapeColors <- function(data, nbreaks=5, missingcol="gray88", rdgrbl=c(0,0,1), mycolors=NULL, max_opac=0.55){
  if(length(nbreaks) == 1) {
    mybreaks <- c(-1, quantile(data,
                               probs = seq(0, 1, length.out=nbreaks+1),
                               na.rm = T))
  } else {
    mybreaks <- c(-1,nbreaks)
  }
  if(!is.null(mycolors)){
    mycols <- mycolors
  } else {
    mycols <- rgb(rdgrbl[1],rdgrbl[2],rdgrbl[3],
                  seq(0.05,max_opac, length.out = length(mybreaks)-1))
  }
  mycols[1] <- missingcol
  data[is.na(data)] <- -.1
  mycolorscheme <- cut(data, mybreaks) %>%
    as.numeric()
  mycolorscheme <- mycols[mycolorscheme]
  levs <- levels(cut(data, mybreaks))
  levs[1] <- "No Data"
  return(list(mycolorscheme, levs, mycols))
}
``` 
   
Let's first use this function to get a map of zip codes where the color of each zip code is related to the positive case rate. For now, we'll divide the case rates into quintiles in order to match the map published by the Furman Center.   
```{r map2, exercise=TRUE, exercise.setup = 'load-data'}
col_lev <- getShapeColors(round(zcta$Positive/zcta$Population*1000,1), 
                          5, 
                          "white", 
                          mycolors=viridis(6))

plot(NYC_zips, col = col_lev[[1]], 
     main = "Positive Tests Per 1000 People by Zip Code", 
     cex = 10, lwd=0.01)

legend("topleft", 
       legend = col_lev[[2]], 
       fill = col_lev[[3]], 
       cex = 0.8, 
       title = "Positive Tests per 1000 People")
```   

  
Next, we could plot the same map but change the colors so that they reflect the proportion of the population that is non-white.  
```{r map3, exercise=TRUE, exercise.setup = 'load-data'}
col_lev <- getShapeColors(round((1-zcta$White_Total/zcta$Population)*100,1), 
                          5, 
                          "white", 
                          mycolors=viridis(6))

plot(NYC_zips, col = col_lev[[1]], 
     main = "Percent of Population that is Non-White", 
     cex = 10, lwd=0.01)

legend("topleft", 
       legend = col_lev[[2]], 
       fill = col_lev[[3]], 
       cex = 0.8, 
       title = "% Non-White")
```    
  
An open-ended question about trying to visualize these two things on a plot simultaneously: Suppose that we wanted to see how well the two maps above "line up" (without scrolling back and forth between them). Here's one way we might try to do that (although maybe there are better ways.. or maybe this is an ill-advised endeavor altogether): We can plot the case rate quintile as increasingly dark shades of transparant blue, and the proportion non-white as increasingly dark shades of transparant red. Finally, we can overlay the maps, one on top of the other. Then any zip code with similar levels of these two variables will appear purple, while zip codes with a high-level of one variable, but not the other, will appear red or blue.   

```{r map4, exercise=TRUE, exercise.setup = 'load-data'}
col_lev1 <- getShapeColors(round(zcta$Positive/zcta$Population*1000,1), 
                           5, 
                           rdgrbl = c(0,0,1))
col_lev2 <- getShapeColors(round((1-zcta$White_Total/zcta$Population)*100,1), 
                           5, 
                           rdgrbl = c(1,0,0))

par(mfrow=c(1,3))
plot(NYC_zips, col = col_lev1[[1]], 
     main = "", 
     cex = 10, lwd=0.01)
legend("topleft", 
       legend = col_lev1[[2]], 
       fill = col_lev1[[3]], 
       cex = 0.8, 
       title = "Pos Tests per 1000")

plot(NYC_zips, col = col_lev2[[1]], 
     main = "", 
     cex = 10, lwd=0.01)
legend("topleft", 
       legend = col_lev2[[2]], 
       fill = col_lev2[[3]], 
       cex = 0.8, 
       title = "% Non-White")


plot(NYC_zips, col = col_lev2[[1]], 
     main = "", 
     cex = 10, lwd=0.01)
plot(NYC_zips, col = col_lev1[[1]], 
     main = "", 
     cex = 10, lwd=0.01, add=T)
```   
   
   
We can also look at that plot more up close, and combine it with a scatter plot, which might make the picture a little clearer (note the purple dots in the scatter plot fall closer to the imaginary line you might draw through all the points; more scattered points are more red or blue):  
```{r map5, exercise=TRUE, exercise.setup = 'load-data'}
col_lev1 <- getShapeColors(round(zcta$Positive/zcta$Population*1000,1), 
                           5, 
                           rdgrbl = c(0,0,1))
col_lev2 <- getShapeColors(round((1-zcta$White_Total/zcta$Population)*100,1), 
                           5, 
                           rdgrbl = c(1,0,0))

par(mfrow=c(1,2))
plot(NYC_zips, col = col_lev2[[1]], 
     main = "", 
     cex = 10, lwd=0.01)
plot(NYC_zips, col = col_lev1[[1]], 
     main = "", 
     cex = 10, lwd=0.01, add=T)

plot(round((1-zcta$White_Total/zcta$Population)*100,1),
     round(zcta$Positive/zcta$Population*1000,1),
     col = col_lev2[[1]],
     main = "",
     xlab = "Proportion Non-White",
     ylab = "Pos Cases per 1000 Ppl",
     pch = 16)
points(round((1-zcta$White_Total/zcta$Population)*100,1),
       round(zcta$Positive/zcta$Population*1000,1),
       col = col_lev1[[1]],
       pch = 16)
```   


## Exploration Workspace  
Now that we've taken a look at some of these variables, this space is left to you for any additional questions you may want to ask. Some code has been copied for you here, which you can run and then alter, in order to address new questions. Questions to think about: What other variables could you look at that might be related to the positive case rate? How are these variables related to each other? How is the number of tests administered related to both the population and positive case rate?  
\newline  
\newline  
### Code to examine the data  
```{r practice1, exercise=TRUE, exercise.setup = 'load-data'}
str(zcta)  
```   
  
### Code to construct a 1-way table   
```{r practice2, exercise=TRUE, exercise.setup = 'load-data'}
inc <- zcta %>% 
  mutate(Med_Inc_Lev = ntile(Med_Income, 3)) %>%
  group_by(Med_Inc_Lev) %>%
  summarise(Cases_per_1000 = round(sum(Positive)/sum(Population)*1000, 2))
inc <- inc[-nrow(inc),]
inc
```  

### Code to construct a 2-way table of case rates  
```{r practice3, exercise=TRUE, exercise.setup = 'load-data'}
inc_propwhite <- zcta %>% 
  mutate(White_Prop = round((White_Total)/Race_Total), 2) %>%
  mutate(White_Prop_Lev = ntile(White_Prop, 3)) %>%
  mutate(Med_Inc_Lev = ntile(Med_Income, 3)) %>%
  group_by(White_Prop_Lev, Med_Inc_Lev) %>%
  summarise(Cases_per_1000 = round(sum(Positive)/sum(Population)*1000, 2)) %>%
  spread(White_Prop_Lev, Cases_per_1000, fill=0)
inc_propwhite <- inc_propwhite[-nrow(inc_propwhite),-ncol(inc_propwhite)]
inc_propwhite[,1] <- c("Low Income", "Med Income", "High Income")
colnames(inc_propwhite) <- c(NA, "Low Prop White", "Med Prop White", "High Prop White")
inc_propwhite
```    

### Code to construct a scatter plot   
```{r practice4, exercise=TRUE, exercise.setup = 'load-data'}
plot(zcta$Med_Income,
     round(zcta$Positive/zcta$Population*1000,1), 
     xlab="median income", 
     ylab="pos cases per 1000 ppl", 
     pch=16)
```    
  
### Code construct a map  
```{r practice5, exercise=TRUE, exercise.setup = 'load-data'}
col_lev <- getShapeColors(round(zcta$Positive/zcta$Population*1000,1), 
                          5, 
                          "white", 
                          rdgrbl = c(0,1,0),
                          max_opac = 0.7)

plot(NYC_zips, col = col_lev[[1]], 
     main = "Positive Tests Per 1000 People by Zip Code", 
     cex = 10, lwd=0.01)

legend("topleft", 
       legend = col_lev[[2]], 
       fill = col_lev[[3]], 
       cex = 0.8, 
       title = "Positive Tests per 1000 People")
```
   
### Empty workspace for you!  

```{r practice_blank, exercise=TRUE, exercise.setup = 'load-data'}

```  